{"version":3,"file":"index.js","mappings":";;;;;;AAAA;;;;;;;;AAAA;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC7BA;AACA;;;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["../C:\\Users\\Administrator\\AppData\\Roaming\\npm\\node_modules\\@vercel\\ncc\\dist\\ncc\\@@notfound.js","../webpack/bootstrap","../webpack/runtime/compat",".././src/index.js"],"sourcesContent":[null,"// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\tvar threw = true;\n\ttry {\n\t\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\t\tthrew = false;\n\t} finally {\n\t\tif(threw) delete __webpack_module_cache__[moduleId];\n\t}\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","\nif (typeof __webpack_require__ !== 'undefined') __webpack_require__.ab = __dirname + \"/\";","const core = require('@actions/core');\r\nconst github = require('@actions/github');\r\n\r\nasync function run() {\r\n  try {\r\n    // Get inputs\r\n    const token = core.getInput('github_token', { required: true });\r\n    const protectedBranches = core.getInput('protected_branches') || 'main,master,develop,development,staging,production';\r\n    const dryRun = core.getInput('dry_run') === 'true';\r\n    const deleteOnMerge = core.getInput('delete_on_merge') !== 'false'; // default true\r\n    const deleteStale = core.getInput('delete_stale') === 'true';\r\n    const staleDays = parseInt(core.getInput('stale_days') || '90', 10);\r\n\r\n    // Get context\r\n    const context = github.context;\r\n    const octokit = github.getOctokit(token);\r\n\r\n    core.info(`ðŸ§¹ Branch Cleanup Bot started`);\r\n    core.info(`Repository: ${context.repo.owner}/${context.repo.repo}`);\r\n    core.info(`Event: ${context.eventName}`);\r\n\r\n    // Parse protected branches\r\n    const protectedBranchList = protectedBranches\r\n      .split(',')\r\n      .map(b => b.trim())\r\n      .filter(b => b.length > 0);\r\n\r\n    core.info(`Protected branches: ${protectedBranchList.join(', ')}`);\r\n\r\n    // Handle pull_request events (merged PRs)\r\n    if (context.eventName === 'pull_request' && deleteOnMerge) {\r\n      const pr = context.payload.pull_request;\r\n      \r\n      if (pr.merged === true) {\r\n        const branchName = pr.head.ref;\r\n        const branchOwner = pr.head.repo.owner.login;\r\n        const repoOwner = context.repo.owner;\r\n\r\n        core.info(`âœ… PR #${pr.number} was merged`);\r\n        core.info(`Branch to delete: ${branchName}`);\r\n\r\n        // Check if branch is from the same repo (not a fork)\r\n        if (branchOwner !== repoOwner) {\r\n          core.info(`â­ï¸ Skipping: Branch is from a fork (${branchOwner})`);\r\n          return;\r\n        }\r\n\r\n        // Check if branch is protected\r\n        if (protectedBranchList.includes(branchName)) {\r\n          core.info(`ðŸ”’ Skipping: Branch '${branchName}' is protected`);\r\n          return;\r\n        }\r\n\r\n        // Check if branch matches protected patterns\r\n        const isProtectedPattern = protectedBranchList.some(pattern => {\r\n          if (pattern.includes('*')) {\r\n            const regex = new RegExp('^' + pattern.replace(/\\*/g, '.*') + '$');\r\n            return regex.test(branchName);\r\n          }\r\n          return false;\r\n        });\r\n\r\n        if (isProtectedPattern) {\r\n          core.info(`ðŸ”’ Skipping: Branch '${branchName}' matches a protected pattern`);\r\n          return;\r\n        }\r\n\r\n        // Delete the branch\r\n        if (dryRun) {\r\n          core.info(`ðŸ” DRY RUN: Would delete branch '${branchName}'`);\r\n        } else {\r\n          try {\r\n            await octokit.rest.git.deleteRef({\r\n              owner: context.repo.owner,\r\n              repo: context.repo.repo,\r\n              ref: `heads/${branchName}`\r\n            });\r\n            core.info(`ðŸ—‘ï¸ Successfully deleted branch '${branchName}'`);\r\n          } catch (error) {\r\n            if (error.status === 422) {\r\n              core.warning(`Branch '${branchName}' was already deleted`);\r\n            } else {\r\n              throw error;\r\n            }\r\n          }\r\n        }\r\n      } else {\r\n        core.info(`â„¹ï¸ PR #${pr.number} was closed but not merged - no action taken`);\r\n      }\r\n    }\r\n\r\n    // Handle workflow_dispatch or schedule events (stale branch cleanup)\r\n    if ((context.eventName === 'workflow_dispatch' || context.eventName === 'schedule') && deleteStale) {\r\n      core.info(`ðŸ” Scanning for stale branches (older than ${staleDays} days)...`);\r\n\r\n      // Get all branches\r\n      const { data: branches } = await octokit.rest.repos.listBranches({\r\n        owner: context.repo.owner,\r\n        repo: context.repo.repo,\r\n        per_page: 100\r\n      });\r\n\r\n      core.info(`Found ${branches.length} branches`);\r\n\r\n      const now = new Date();\r\n      const staleThreshold = new Date(now.getTime() - staleDays * 24 * 60 * 60 * 1000);\r\n      let deletedCount = 0;\r\n\r\n      for (const branch of branches) {\r\n        const branchName = branch.name;\r\n\r\n        // Skip protected branches\r\n        if (protectedBranchList.includes(branchName)) {\r\n          continue;\r\n        }\r\n\r\n        // Skip protected patterns\r\n        const isProtectedPattern = protectedBranchList.some(pattern => {\r\n          if (pattern.includes('*')) {\r\n            const regex = new RegExp('^' + pattern.replace(/\\*/g, '.*') + '$');\r\n            return regex.test(branchName);\r\n          }\r\n          return false;\r\n        });\r\n\r\n        if (isProtectedPattern) {\r\n          continue;\r\n        }\r\n\r\n        // Get the last commit date\r\n        try {\r\n          const { data: commit } = await octokit.rest.repos.getCommit({\r\n            owner: context.repo.owner,\r\n            repo: context.repo.repo,\r\n            ref: branch.commit.sha\r\n          });\r\n\r\n          const commitDate = new Date(commit.commit.committer.date);\r\n\r\n          if (commitDate < staleThreshold) {\r\n            const daysSinceCommit = Math.floor((now - commitDate) / (1000 * 60 * 60 * 24));\r\n            \r\n            if (dryRun) {\r\n              core.info(`ðŸ” DRY RUN: Would delete stale branch '${branchName}' (last commit: ${daysSinceCommit} days ago)`);\r\n            } else {\r\n              await octokit.rest.git.deleteRef({\r\n                owner: context.repo.owner,\r\n                repo: context.repo.repo,\r\n                ref: `heads/${branchName}`\r\n              });\r\n              core.info(`ðŸ—‘ï¸ Deleted stale branch '${branchName}' (last commit: ${daysSinceCommit} days ago)`);\r\n              deletedCount++;\r\n            }\r\n          }\r\n        } catch (error) {\r\n          core.warning(`Failed to process branch '${branchName}': ${error.message}`);\r\n        }\r\n      }\r\n\r\n      core.info(`âœ… Stale branch cleanup complete. Deleted ${deletedCount} branches.`);\r\n    }\r\n\r\n    core.info('âœ¨ Branch Cleanup Bot finished successfully');\r\n\r\n  } catch (error) {\r\n    core.setFailed(`âŒ Action failed: ${error.message}`);\r\n  }\r\n}\r\n\r\nrun();\r\n\r\n"],"names":[],"sourceRoot":""}